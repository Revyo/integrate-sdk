---
title: OAuth Authorization Flow
description: Complete guide to OAuth authentication with the Integrate SDK
---

# OAuth Authorization Flow

The Integrate SDK provides a complete OAuth 2.0 Authorization Code Flow with PKCE for securely authenticating users with third-party services like GitHub and Gmail.

## Overview

The SDK handles the entire OAuth flow for you:

1. **Initiate Authorization** - Opens OAuth provider's authorization page
2. **User Grants Permissions** - User authorizes your app
3. **Handle Callback** - SDK receives authorization code
4. **Exchange for Token** - Server exchanges code for access token
5. **Store Token** - Access token is stored per provider in localStorage

## Quick Start

### Browser-Side Authorization (Popup Mode)

```typescript
import { createMCPClient, githubPlugin } from 'integrate-sdk';

const client = createMCPClient({
  plugins: [
    githubPlugin({
      clientId: process.env.GITHUB_CLIENT_ID,
      clientSecret: process.env.GITHUB_CLIENT_SECRET,
    }),
  ],
  oauthFlow: {
    mode: 'popup', // Opens authorization in a popup window
    popupOptions: {
      width: 600,
      height: 700,
    },
  },
});

// Check if user is already authorized
const isAuthorized = await client.isAuthorized('github');

if (!isAuthorized) {
  // Initiate OAuth flow - opens popup window
  await client.authorize('github');
}

// Now you can make API calls
const repos = await client.github.listRepos({ username: 'octocat' });
```

### Browser-Side Authorization (Redirect Mode)

```typescript
const client = createMCPClient({
  plugins: [
    githubPlugin({
      clientId: process.env.GITHUB_CLIENT_ID,
      clientSecret: process.env.GITHUB_CLIENT_SECRET,
    }),
  ],
  oauthFlow: {
    mode: 'redirect', // Redirects current window (default)
  },
});

// On your main page
if (!await client.isAuthorized('github')) {
  // This will redirect to GitHub's OAuth page
  await client.authorize('github');
}

// After redirect back from OAuth callback route
// The SDK automatically:
// 1. Picks up the callback params from URL hash
// 2. Exchanges code for access token
// 3. Stores the token in localStorage
// Just check if authorization is complete:
if (await client.isAuthorized('github')) {
  console.log('GitHub is authorized!');
  // Token is already persisted - no need to manually save
}
```

## Client-Side vs Server-Side

### ✅ Client-Side (Browser) - Full Functionality

The SDK provides full OAuth UI flows in browser environments:

```typescript
// Browser environment
const client = createMCPClient({
  plugins: [githubPlugin({ /* ... */ })],
  oauthFlow: { mode: 'popup' },
});

// ✅ Full OAuth UI works
await client.authorize('github');

// ✅ Make API calls
const repos = await client.github.listRepos({ username: 'octocat' });
```

### ⚠️ Server-Side (Node.js) - API Calls Only

On the server, OAuth UI flows aren't available, but you can make API calls with provider access tokens:

```typescript
// Node.js/Server environment
const client = createMCPClient({
  plugins: [githubPlugin({ /* ... */ })],
});

// Set the access token for the provider
client.setProviderToken('github', {
  accessToken: userAccessToken, // From your database
  tokenType: 'Bearer',
  expiresIn: 3600,
});

// ✅ API calls work fine
const repos = await client.github.listRepos({ username: 'octocat' });

// ❌ OAuth UI flows will throw an error
await client.authorize('github'); 
// Error: OAuthWindowManager can only be used in browser environments
```

## Full-Stack Pattern

### 1. Frontend (Browser) - Handle Authorization

```typescript
// src/lib/integrate.ts
import { createMCPClient, githubPlugin } from 'integrate-sdk';

export const client = createMCPClient({
  plugins: [
    githubPlugin({
      clientId: process.env.NEXT_PUBLIC_GITHUB_CLIENT_ID,
      clientSecret: process.env.NEXT_PUBLIC_GITHUB_CLIENT_SECRET,
    }),
  ],
  oauthFlow: {
    mode: 'popup',
    popupOptions: { width: 600, height: 700 },
  },
});

// Authorization component
export async function authorizeGitHub() {
  try {
    await client.authorize('github');
    
    // Get access token for the provider
    const tokenData = client.getProviderToken('github');
    
    if (tokenData) {
      // Send to your backend to store
      await fetch('/api/auth/save-token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          provider: 'github', 
          accessToken: tokenData.accessToken,
          refreshToken: tokenData.refreshToken,
          expiresAt: tokenData.expiresAt,
        }),
      });
    }
    
    return true;
  } catch (error) {
    console.error('Authorization failed:', error);
    return false;
  }
}
```

### 2. Backend API Route - Store Token

```typescript
// pages/api/auth/save-token.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { db } from '@/lib/db';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { provider, accessToken, refreshToken, expiresAt } = req.body;
  const userId = req.session.userId; // Your session management

  // Store in database
  await db.userTokens.upsert({
    where: { userId_provider: { userId, provider } },
    update: { 
      accessToken, 
      refreshToken, 
      expiresAt, 
      updatedAt: new Date() 
    },
    create: { 
      userId, 
      provider, 
      accessToken, 
      refreshToken, 
      expiresAt 
    },
  });

  res.status(200).json({ success: true });
}
```

### 3. Backend - Use Token for API Calls

```typescript
// pages/api/github/repos.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { createMCPClient, githubPlugin } from 'integrate-sdk';
import { db } from '@/lib/db';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const userId = req.session.userId;
  
  // Get user's stored token
  const userToken = await db.userTokens.findUnique({
    where: { userId_provider: { userId, provider: 'github' } },
  });

  if (!userToken) {
    return res.status(401).json({ error: 'Not authorized' });
  }

  // Create client and set provider token
  const client = createMCPClient({
    plugins: [
      githubPlugin({
        clientId: process.env.GITHUB_CLIENT_ID,
        clientSecret: process.env.GITHUB_CLIENT_SECRET,
      }),
    ],
  });

  // Set the access token for the provider
  client.setProviderToken('github', {
    accessToken: userToken.accessToken,
    refreshToken: userToken.refreshToken,
    tokenType: 'Bearer',
    expiresIn: 3600, // You may want to calculate this from expiresAt
    expiresAt: userToken.expiresAt,
  });

  try {
    // Make API call on behalf of user
    const repos = await client.github.listRepos({
      username: req.query.username as string,
    });
    
    res.status(200).json(repos);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}
```

## Authorization Methods

### Check Authorization Status

```typescript
// Check if a provider is authorized
const isAuthorized = await client.isAuthorized('github');

if (isAuthorized) {
  console.log('User has authorized GitHub');
} else {
  console.log('User needs to authorize GitHub');
}

// Get detailed authorization status
const status = await client.getAuthorizationStatus('github');
console.log('Status:', status);
// {
//   provider: 'github',
//   authorized: true,
//   scopes: ['repo', 'user'],
//   expiresAt: '2024-12-31T23:59:59Z'
// }

// Get all authorized providers
const authorizedProviders = await client.authorizedProviders();
console.log('Authorized:', authorizedProviders); // ['github']
```

### Initiate Authorization

```typescript
// Popup mode
const client = createMCPClient({
  plugins: [githubPlugin({ /* ... */ })],
  oauthFlow: { mode: 'popup' },
});

// Opens popup window for OAuth
await client.authorize('github');

// Redirect mode
const client = createMCPClient({
  plugins: [githubPlugin({ /* ... */ })],
  oauthFlow: { mode: 'redirect' },
});

// Redirects current window to OAuth provider
await client.authorize('github');
```

### Handle OAuth Callback

For redirect mode, create a simple redirect handler:

```typescript
// app/oauth/callback/route.ts
import { createOAuthRedirectHandler } from 'integrate-sdk';

export const GET = createOAuthRedirectHandler({
  redirectUrl: '/dashboard', // Where to redirect after OAuth
});
```

The SDK automatically picks up the OAuth callback data and completes the flow.

## Provider Token Management

### Automatic Token Persistence

The SDK automatically stores provider tokens in `localStorage` when you authorize:

```typescript
// Authorize GitHub
await client.authorize('github');

// Token is automatically saved to localStorage
// On page reload, the SDK automatically loads it

// Check if token exists
const tokenData = client.getProviderToken('github');
console.log('Has GitHub token:', !!tokenData);
```

### Manual Token Management

```typescript
// Get token for a provider
const tokenData = client.getProviderToken('github');
if (tokenData) {
  console.log('Access token:', tokenData.accessToken);
  console.log('Expires at:', tokenData.expiresAt);
}

// Set token manually (e.g., after loading from your database)
client.setProviderToken('github', {
  accessToken: 'gho_...',
  refreshToken: 'ghr_...',
  tokenType: 'Bearer',
  expiresIn: 3600,
  expiresAt: '2025-01-01T00:00:00Z',
});

// Clear token for a specific provider
client.disconnectProvider('github');

// Clear all provider tokens
client.clearSessionToken(); // Clears all tokens
```

### Multi-Provider Token Storage

Each provider's token is stored independently:

```typescript
// Authorize multiple providers
await client.authorize('github');
await client.authorize('gmail');

// Each has its own token
const githubToken = client.getProviderToken('github');
const gmailToken = client.getProviderToken('gmail');

// Disconnect one provider doesn't affect others
await client.disconnectProvider('github');

// Gmail token still works
const emails = await client.gmail.listEmails({ maxResults: 10 });
```

## Multiple Providers

```typescript
const client = createMCPClient({
  plugins: [
    githubPlugin({
      clientId: process.env.GITHUB_CLIENT_ID,
      clientSecret: process.env.GITHUB_CLIENT_SECRET,
    }),
    gmailPlugin({
      clientId: process.env.GMAIL_CLIENT_ID,
      clientSecret: process.env.GMAIL_CLIENT_SECRET,
    }),
  ],
  oauthFlow: {
    mode: 'popup',
  },
});

// Authorize GitHub
if (!await client.isAuthorized('github')) {
  await client.authorize('github');
}

// Authorize Gmail
if (!await client.isAuthorized('gmail')) {
  await client.authorize('gmail');
}

// Now use both
const repos = await client.github.listRepos({ username: 'octocat' });
const emails = await client.gmail.listEmails({ maxResults: 10 });
```

## Custom OAuth Callback Handler

```typescript
const client = createMCPClient({
  plugins: [githubPlugin({ /* ... */ })],
  oauthFlow: {
    mode: 'popup',
    onAuthCallback: async (provider, code, state) => {
      // Custom processing of OAuth callback
      console.log(`OAuth callback for ${provider}`);
      console.log('Code:', code);
      console.log('State:', state);
      
      // You can add analytics, logging, etc.
      await analytics.track('oauth_completed', { provider });
    },
  },
});
```

## Error Handling

```typescript
try {
  await client.authorize('github');
} catch (error) {
  if (error.message.includes('popup was blocked')) {
    console.error('Please allow popups for this site');
    // Show user instructions to enable popups
  } else if (error.message.includes('closed by user')) {
    console.error('Authorization cancelled by user');
  } else if (error.message.includes('timed out')) {
    console.error('Authorization timed out');
  } else {
    console.error('Authorization failed:', error);
  }
}
```

## Security Best Practices

### 1. Never Expose Client Secret in Browser

```typescript
// ❌ BAD - Client secret exposed in browser
const client = createMCPClient({
  plugins: [
    githubPlugin({
      clientId: 'public-id',
      clientSecret: 'secret-key-123', // Exposed!
    }),
  ],
});
```

```typescript
// ✅ GOOD - Use environment variables
const client = createMCPClient({
  plugins: [
    githubPlugin({
      clientId: process.env.NEXT_PUBLIC_GITHUB_CLIENT_ID,
      clientSecret: process.env.NEXT_PUBLIC_GITHUB_CLIENT_SECRET,
    }),
  ],
});
```

### 2. Store Tokens Securely

```typescript
// ✅ GOOD - Store in httpOnly cookie (server-side)
// Set in your API route:
res.setHeader('Set-Cookie', `session_token=${sessionToken}; HttpOnly; Secure; SameSite=Strict`);

// ✅ ACCEPTABLE - localStorage for client-only apps
localStorage.setItem('integrate_token', sessionToken);

// ❌ BAD - Storing in global variables or unencrypted storage
window.sessionToken = sessionToken; // Exposed!
```

### 3. Validate OAuth State Parameter

The SDK automatically generates and validates the state parameter to prevent CSRF attacks. The state is checked in `handleOAuthCallback()`.

### 4. Use HTTPS in Production

Always use HTTPS for OAuth redirects in production:

```typescript
const client = createMCPClient({
  plugins: [
    githubPlugin({
      clientId: process.env.GITHUB_CLIENT_ID,
      clientSecret: process.env.GITHUB_CLIENT_SECRET,
      redirectUri: 'https://yourapp.com/oauth/callback', // HTTPS!
    }),
  ],
});
```

## Next Steps

- Learn about [Re-authentication & Token Refresh](/docs/guides/advanced-usage#re-authentication--token-refresh)
- Explore [Error Handling](/docs/guides/advanced-usage#error-handling)
- Check out complete examples in the [repository](https://github.com/Revyo/integrate-sdk/tree/main/examples)

